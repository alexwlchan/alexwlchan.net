---
layout: post
title: Digital decluttering
summary:
tags:
---
I spent a lot of my formative Internet years in online fandom.
I read novel-length stories about *Doctor Who* characters.
I swooned over fan art of the *Lizzie Bennet Diaries*.
I pored over in-depth analyses of each episode of *Carmilla*.
I was surrounded by the creativity of strangers, sharing my own ideas, and taking the first steps towards my queer awakening.

Most of that is gone now.

Links rot at an extraordinary rate, and much of that early-2010s fan culture has now vanished from the Internet.
Accounts get deleted, websites go down, domain names lapse.
We might think the Internet is written in ink, but really it's more like chalk on a pavement.
Stuff is visible for a while, and over time it washes away.

Every fan eventually realises that if there's something they love, they have to save your own copy.
We all learnt this lesson the hard way, when we went to find something we remembered from years ago, and it had vanished from the face of the Internet.

So I started saving, and I kept saving.
Digital storage has become cheap and abundant, and I could afford to keep local copies of everything.
I didn't have to be picky with what I was saving.

I saved web pages and photos and PDFs and videos and audio files, and I wrote scripts to save as much as possible, all so I'd never lose anything again.
I kept every photo I'd ever taken, every tweet I'd written, every link I'd read.
If you look at early posts on this site or my old GitHub repos, you'll see my excitement at code that could scrape down data and squirrel it away on my hard drive.
I always thought "what if I want to go back to this someday?"

Looking back, I could skip 95% of this data and I'd be fine.
There are some things that I'm glad I saved, but there's an awful lot of other stuff that I've never gone back to, and I know I'm never going to look at again.
And because I was more interested in saving lots of files than organising what I had, it's difficult to find that 5% I actually care about.

I'm trying to simplify.
My data is currently split across my internal disk and several external hard drives, and those external drives need to be replaced soon.
Ideally I'd like to shrink my data until it fits on a single, internal disk.

As I save new stuff today, I'm trying to be more intentional about what I keep.
Before I save something, I ask myself "when will you want to look at this again?"
If I can't imagine a scenario in which I'd be glad to have saved this particular thing, I don't save it.
I've been collecting for fifteen years, and I know what sort of stuff I go back to.
Heartfelt stories and in-depth essays? Yes.
Current affairs and political news? Not so much.

That's slowing the influx of new data, but there's still the data I've already collected.
I've been gradually pruning it, deleting what I don't want and organising what I do.
It's a slow and arduous process, because there's no easy way to automate this -- ultimately, I have to look at every item and decide if it's worth keeping.

It took me years to accumulate this data, so I'm not going to clear it in a week.
I've already spent months chipping away at it, reviewing a few items a day, and there's plenty more to go.
So far I've reviewed all the photos I've taken, the videos I saved, the podcasts I kept.
I'm midway through cleaning up my bookmarks folder, and after that are my tweets.
I've shed thousands of files and tossed an entire hard drive, but more importantly, I can now find the items I actually care about.

Many nerds treat it as inevitable that our data gets bigger over time; that we'll always need more storage than we did in the past.
I don't think that's for certain, and I'm not sure it's sustainable -- we need to be more intentional about our data.
Modern storage means we can keep everything, but that doesn't mean we should.
"As much as I can save" isn't a collecting strategy; it's hoarding.

In the rest of this post, I'll talk about some steps I've taken to simplify and manage my digital collections.
I still want to keep some of what I've saved, but I'm getting rid of a lot of the clutter.
I'm gradually creating a more selective and well-organised archive.

<!-- [ink]: https://youtu.be/6HbrQMgOUFw?si=n-j_yp7moS8YAx9L&t=32 -->

## Deciding what to keep

I've found a few questions which have helped me decide whether something is worth keeping.

-   *When will you want to look at this again?*
    If I can't imagine a scenario when I'd be glad to have this file, I can probably delete it.

-   *Do I remember what this is?*
    As I go through my backlog, I'm finding a lot of files that I've completely forgotten saving.
    If I don't remember them now, I'm unlikely to look for them in future or be sad that they're gone.

    For example, I found lots of photos I'd taken of places and buildings that I don't remember.
    I had no idea what the blurry grey rectangle was, where it was taken, or why I thought it was important.
    I deleted all of those photos.

-   *Did I keep any notes about it?*
    If my past self wrote detailed notes and explanation of why I thought it was important, I can decide whether it's still worth keeping.
    If I didn't write anything, it probably wasn't that important.
    I've deleted hundreds of bookmarks which were just a URL, for which my past self didn't leave any other context.

    This is a useful litmus test as I save new material -- if it's not worth taking a minute to write a sentence or two of description, is it really worth saving?

-   *Is it timeless or time-limited?*
    If something is about current affairs or the news, I'm unlikely to want it for the long-term.
    It might be useful for a historian, but that's not me.
    I've purged a lot of saved podcast episodes that were speculating about the Brexit vote, the Python 2 transition, and upcoming Apple events.

-   *If I didn't save it myself, would I struggle to find it again later?*
    Some of my now-deleted bookmarks were links to basic reference material.
    That's information I could easily find again through Google, and if I was looking for it I wouldn't think to look in my personal archives.

    On the other hand, a lot of fannish and queer communities are quite hard to find online.
    I might struggle to find stuff again if I don't have a link, but I can find it easily if I save a copy in my personal, local archives.

I'm now considering these questions whenever I save something new.
I'm also applying them to my existing pile of data, and deleting items that pass muster.

## Organising what's left

Once I've decided to save something, there's a follow-up question: *"How will I find it later?"*
This is the big problem with my previous systems, where data disappeared into a void, unable to be found again.
I want to be able to find things that I've saved.

I'm adding a small amount of metadata to everything I'm saving.
This metadata allows me to record why I thought a file was important, and add some notes and keywords that I can search for later when I'm looking for it.

Adding this metadata is a manual process, which adds a bit of friction to saving anything new.
I'm okay with this -- taking a minute or so to write some notes will make files much easier to find later, and encourages me to be thoughtful about what I'm saving.
This step is a moment to pause, reflect, and double check that this thing really is worth saving.

It's also a lightweight process, and my metadata is more of a folksonomy than a rigidly-defined set of categories.
This is to ensure that I always can add metadata, and I don't have to think too hard about it -- otherwise I put it off, and I end up with a desktop of unsorted files because they don't fit into the organisation system I've build.

The metadata I'm adding varies by format -- for example, a photo I've taken needs different metadata to a web page I've saved -- but there are two fields I'm using pretty consistently:

*   *The date when I created or saved this file.*
    This is useful because it allows me to anchor data to the memory of what I was doing at the time.
    ("Hey, where's that article I read on holiday last year?")
    The level of granularity varies -- for some files I know exactly what day I created something, for others I only


---


Different models for each type of thing
* e.g. photo needs very different metadata to fanfiction, or screenshot
* models are lightweight, only a handful of fields to fill in
	* e.g. video = title, source URL, description, tags, duration, path to downloaded file, date saved
* deliberately generic, not tied to particular service

two consistent themes emerging

* organise by year
* organise by keyword tags

## Organising my digital archive

As I go through my data and choose what I want to keep, I'm gradually sorting it into a few different piles.

# part 2: organising my digital archives

trying to be more intentional about what I keep, new stuff
simple rule: "when will I want to look at this again"

follow-up question: "how will i find it when I want to?"
don't want to be creating stuff thrown into a void never to be seen again
want some way to add metadata to items I'm saving, so I can find them again
don't want to be onerous task

Different models for each type of thing
* e.g. photo needs very different metadata to fanfiction, or screenshot
* models are lightweight, only a handful of fields to fill in
	* e.g. video = title, source URL, description, tags, duration, path to downloaded file, date saved
* deliberately generic, not tied to particular service

two consistent themes: year and tag

one consistent theme: I love keyword tags
* not hierarchical folders, require single point of entry
* tags allow multiple points of entry
* e.g. if I save a music video I like, am I going to search for "music" or the genre or the artist's name?
* tagging: don't have to choice, apply to all
* theoretically can even combine tags for more filtered queries -- in practice rare, with smaller collections (few thousand items) a single tag gets me close enough

key is that I can tag quickly
* never wondering how I should tag something; if I have to think about it I'll get indecision and it gets thrown in the great bucket of "uncategorised" never to be seen again
* tags are v flexible, add as and when
* don't always tag consistently
* more folksonomy than taxonomy
* taxonomy would take a long time to create! is hard! requires library skills! big arguments!
* only person who has to understand these is me!
* and gradually refine over time
* (e.g. with fuzzy matching to find similar tags)

tags are v flexible, allow namespacing
* e.g. in my bookmarks I have `type:fic` `type:opinion` `type:howto` which create a layer of faceting within tags
* could be a separate `type` field but can shoehorn into tags + more flexible to add new categories as and when

then to retrieve? throw shuffle in the mix

lightweight data model, few fields, tags
* have used this approach across a variety of projects
* been pretty successful

> Your outline for part 2 looks good. It focuses on your approach to organizing digital archives and complements the first part well. Here's a summary of the structure I see:
>
> 1. New approach to digital storage
>     - Being intentional about keeping items
>     - Key questions: "When will I want to look at this again?" and "How will I find it when I want to?"
> 2. Importance of metadata
>     - Adding metadata to saved items for easy retrieval
>     - Balancing thoroughness with ease of use
> 3. Different models for different types of content
>     - Examples of metadata fields for various content types
>     - Keeping models lightweight and generic
> 4. Focus on keyword tags
>     - Advantages over hierarchical folder systems
>     - Flexibility and multiple points of entry
> 5. Tagging strategy
>     - Quick and intuitive tagging
>     - Folksonomy approach
>     - Gradual refinement over time
> 6. Advanced tagging techniques
>     - Namespacing within tags
>     - Creating facets within the tagging system
> 7. Conclusion
>     - Summary of the lightweight data model approach
>     - Success across various projects
>
> This structure effectively builds upon the ideas introduced in part 1, moving from the problem of digital clutter to your solution for organizing digital archives. It provides a clear progression of ideas and practical insights into your organizational system.

# part 3: tools for my digital archives

[[sucked down data, lots of machine-readable files but no human-readable interface]]

have built these archives over 15 years
* would like them to remain usable for at least as long, ideally longer – rest of my life
* but don't want to be constantly maintaining and tinkering -- better things to do with my time
* have been thinking about how to design system that lasts

preserving software is always a challenge
* need to maintain working environment
* that's hard! world is changing
* operating systems change, language versions go out of date, dependencies break
* yuck

need something static, unchanging
* no environment required
* nothing to break

this is why plain text is so popular for taking notes
* text file or Markdown
* open file format, will remain readable
* not tied to any software package or environment
* highly likely to remain readable

I already use plain text for a lot of stuff!
* e.g. journal entries and reference notes
* v good for linear text
* less good for multimedia or interactivity, e.g. a list of videos

hmm… how to do plain text with interactivity?
* what about static websites?
* this is tech that has been v stable in my life
* not tied to any software package or environment
* highly likely to remain readable
* could open web pages on my 2003 iMac and still look broadly the same on my 2022 MacBook Air

have been gradually building static sites as front-end to my archives
* metadata in machine-readable JavaScript
* low-tech viewer, HTML CSS and vanilla JS
* allows presenting archive in more visual way, with a light sprinkling of interactivity for e.g. tag filters
* opens in web browser on any device, so highly likely to remain readable
* requires minimal tinkering
* and easy to "hack" if I want new features later

not a new idea
* e.g. instagram or twitter archives
* but those are big sprawling web apps!
* 18MB of JavaScript
* I build much simpler, smaller, by hand
* few hundred lines of code at most, keep it simple

this technique has worked well
* now have handful of tiny static websites that provide views into different archives
* e.g. different site for videos and podcasts
* static sites don't scale forever, but that's okay, not looking for big scale solution
* few thousand items at most

https://bytes.yingw787.com/posts/2020/01/13/50years
> I may or may not be working on some personal projects this year that I intend on using for myself. One thing I _know_ I can't do for my personal projects is constantly dedicate time to working on it after I've "shipped". I want to build something once, and ideally use it for the rest of my life (or maybe 20-50 years to start off) without having to worry about having to update something or other or risk losing something important down the line. So thinking about what properties makes software age well is helpful for me in terms of deciding what fundamental technologies (e.g. SQL or REST) I want to incorporate into a system design, and perhaps as equally important, what things I'm willing to trade away.

> Your outline for part 3 looks good and follows logically from the previous two parts. It focuses on the tools and technical approach you've developed for maintaining your digital archives over the long term. Here's a summary of the structure I see:
>
> 1. Introduction: Long-term preservation goals
>     - Desire for longevity (15+ years)
>     - Balancing maintenance with practicality
> 2. Challenges of software preservation
>     - Difficulties with maintaining working environments
>     - Issues with changing technologies
> 3. The appeal of static, unchanging solutions
>     - Benefits of environment-independent approaches
> 4. Plain text as a solution
>     - Advantages for linear text content
>     - Limitations for multimedia and interactivity
> 5. Static websites as a more versatile solution
>     - Stability and longevity of web technologies
>     - Compatibility across different devices and time periods
> 6. Implementation of static sites for archives
>     - Use of machine-readable JavaScript for metadata
>     - Simple HTML, CSS, and vanilla JS for viewing
>     - Benefits of this approach (visual presentation, interactivity, readability, minimal maintenance)
> 7. Comparison to existing solutions
>     - Contrast with large-scale archives (e.g., Instagram, Twitter)
>     - Emphasis on simplicity and hand-crafted approach
> 8. Results and current state
>     - Multiple small static websites for different archive types
>     - Scalability considerations
>
> This structure effectively builds upon the ideas introduced in parts 1 and 2, moving from the problem of digital clutter and organization to the technical implementation of a long-term archival solution. It provides a clear progression of ideas and practical insights into your archival system.
>
> Some thoughts on the structure:
>
> 1. The flow is logical, moving from the challenges of long-term preservation to your specific solution.
> 2. You've effectively explained the rationale behind your choices, particularly the move from plain text to static websites.
> 3. The comparison with existing large-scale solutions helps contextualize your approach.
> 4. The structure allows for easy expansion of each point if needed.

## part 4: specific HTML techniques

metadata in JavaScript file
* example of lightweight JS file
* why JS? so can load in browser from `file://` URI, can't do with JSON/XML
* have python library to manipulate

use relative paths, be explicit
* don't push logic for constructing files for paths to elsewhere, just put the path in the file

HTML page example
* script tag to load JavaScript, then window.addEventListener("DOMContentLoaded") to render as elements on page
* simple example, see viewer loading metadata from machine-readable file

React-like components to render page
* example of `const Tweet = (props) => ```
* use JavaScript template literals
* not full React, data is immutable, doesn't react to state changes
* but simple!

URL query parameters for filtering
* forces page reload, re-render of data
* that's fine
* example of how to get URL query params in modern JS

can write by hand or build simple scripts to modify metadata
* should be simple enough to write and edit by hand
* virtues of plain text!
* but scripts can be helpful for getting the fiddly bits right

verify script
* does every file pointed to by the metadata exist?
* does the metadata point to every file stored locally?
* enforce other rules, e.g. on HTML page linking to filename with `?` is problem

store metadata in git
* track changes to viewer and metadata
* not pushed anywhere
* local backup, easy way to see changes if making batch changes

> Your outline for part 4 looks good and provides a detailed technical discussion of your HTML-based archival system. It serves as a practical extension of the concepts introduced in part 3. Here's a summary of the structure I see:
>
> 1. Metadata storage in JavaScript
>     - Example of lightweight JS file
>     - Rationale for using JS over JSON/XML
>     - Python library for manipulation
> 2. File path management
>     - Use of relative paths
>     - Explicit path declarations
> 3. HTML page structure
>     - Loading JavaScript metadata
>     - Rendering elements on page load
> 4. Component-based rendering
>     - React-like components using JavaScript template literals
>     - Simplicity of approach compared to full React implementation
> 5. Filtering with URL query parameters
>     - Page reload approach for filtering
>     - Accessing URL query params in modern JS
> 6. Metadata management
>     - Manual editing capabilities
>     - Use of scripts for bulk modifications
> 7. Verification process
>     - Checking file existence
>     - Ensuring comprehensive metadata coverage
>     - Enforcing specific rules (e.g., URL formatting)
> 8. Version control with Git
>     - Tracking changes to viewer and metadata
>     - Local backup and change visualization
>
> This structure effectively delves into the technical details of your archival system, providing concrete examples and explanations for each aspect of the implementation.
>
> Some thoughts on the structure:
>
> 1. The flow is logical, moving from data storage to rendering, then to more advanced features like filtering and verification.
> 2. You've balanced high-level explanations with specific code examples, which should be helpful for technically-inclined readers.
> 3. The inclusion of verification and version control shows a comprehensive approach to maintaining the system's integrity.
>
> Potential enhancements:
>
> 1. Consider adding a brief introduction that ties this part to the previous three, explaining why you're now diving into technical details.
> 2. You might want to include a section on potential limitations of this approach and how you address them.
> 3. Adding a conclusion that summarizes the key technical points and how they relate to the overall goals of your archival system could be beneficial.
>
> Overall, this outline for part 4 complements the previous parts well by providing the technical depth that more advanced readers might be looking for. It gives a clear picture of how your theoretical approach to digital archiving is implemented in practice.
>
> To tie all four parts together, you might consider an overarching structure like this:
>
> 1. Part 1: The Problem (Digital Clutter)
> 2. Part 2: The Organizational Approach
> 3. Part 3: The Technical Solution (Overview)
> 4. Part 4: The Technical Solution (Implementation Details)
>
> This structure takes the reader on a journey from recognizing the problem, through developing a solution, to implementing it in detail. It provides a comprehensive look at your approach to digital archiving that should be accessible and interesting to a wide range of readers.

## tools for reviewing new stuff

Build terminal applications
* click.confirm()
* Imgcat

https://koralatov.com/post/140620880181/long-winded
https://www.nayuki.io/page/designing-better-file-organization-around-tags-not-hierarchies