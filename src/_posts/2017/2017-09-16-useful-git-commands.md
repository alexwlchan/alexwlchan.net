---
layout: post
title: Some useful Git commands for CI
summary: A couple of Git commands that I find useful in builds and CI.
tags: git
date: 2017-09-18 18:45:00 +0100
category: "Working with Git"
---

I spend a lot of time writing build scripts for interacting with Git repos.
But Git's documentation is notoriously opaque, and a lot of my Git knowledge comes from word-of-mouth rather than reading the docs.
In that spirit of sharing, these are few of the Git commands I find useful when writing build scripts.

<!-- summary -->

<br/>

```console
$ git rev-parse --show-toplevel
/Users/alexwlchan/repos/alexwlchan.net
```

This command gives you an absolute path to the top-level of your repository.

Often scripts expect to be run from the root of a repo, so assume that `$(pwd)` gives you that path -- but that's not always true.
Using this command always gives you the top of your repo.

Some examples of how I use this:

*   To share an entire repo into a Docker container (I'm on the way to running everything build-related inside Docker)
*   To refer to specific files in a repo within build scripts
*   To open a repo in my text editor or Git client, but from anywhere in the tree

<br/>

```console
$ git rev-parse --show-prefix
_posts/2017/
```

While reading the [git-rev-parse docs][grp] for this post, I stumbled upon this similar command.
This tells you where you are, relative to the top-level of the repo.

I don't have a use for this yet, but I feel like it's bound to come in handy.

[grp]: https://git-scm.com/docs/git-rev-parse

<br/>

```console
$ git diff --exit-code
$ echo $?
0

$ echo "Hello world" >> README.md
$ git diff --exit-code
diff --git a/README.md b/README.md
index a562e4a..a20d083 100644
--- a/README.md
+++ b/README.md
@@ -27,3 +27,4 @@ $ make serve

 A local copy of the site will be served on <http://localhost:5757>.
 If you make changes to the source files, this version will automatically update.
+Hello world

$ echo $?
1
```

Running `git diff` will show you any unstaged changes.
Adding `--exit-code` will cause it to have a non-zero exit code when you have a non-empty diff.

I use this to check that automated tasks have run correctly:

*   Some of my repos use code formatters like [scalafmt][scalafmt] and [pyformat][pyformat].
    To check that the formatters have run correctly on a patch, I have CI tasks that run the autoformat, then use this Git command to check there aren't any changes -- that is, that the autoformat was a no-op.

*   On repos with automatic code generation where the autogen is expensive, I sometimes check in the autogen artefacts.
    Ensuring they're committed correctly is a similar process: run the autogen in CI, then check it didn't change anything -- that all the autogenerated files are already checked in.

This is a pattern I originally read in [the Hypothesis Makefile][hypmake].

(If you just want an exit code and no printed diff, add `--quiet`.)

[hypmake]: https://github.com/HypothesisWorks/hypothesis-python/blob/d79438a7417431ab215d6b0ee0be072d0e51ab6f/Makefile#L102
[scalafmt]: https://scalameta.org/scalafmt/
[pyformat]: https://pypi.org/project/pyformat/

<br/>

```console
$ git diff --name-only
Gemfile
Gemfile.lock
Makefile
README.md

$ git diff --name-only e7791a0 82eb01c
_plugins/static_file_generator.rb
install_jekyll.sh
```

Adding the `--name-only` flag to `git diff` gives you a list of files with changes.

In larger projects, it can be useful to skip some of the tests/builds if there aren't any changes to relevant files.
Output from this command can be input in a decision whether to run certain parts of the build.

A few examples:

*   In pull requests on the Wellcome Platform repo, we [skip running tests][plat_test] on pull requests if there aren't relevant changes compared to current master.
    This reduces the build time on PRs, and allows us to merge faster.
    In a similar vein, builds on master always run the full set of tests, but we [only deploy][plat_deploy] if the patch contains interesting changes.

*   At my last job, people wanted to get notifications for changes to certain files -- for example, if you were responsible for the licensing code, get an email every time there was a change to the licensing files.
    I don't remember whether we finished it, but I remember starting to build it based on output from this command.

*   In Hypothesis, we do a deployment and release for every PR with changes to the core package -- and it's this command which tells us [whether we need a release][hyp].

On its own, this command isn't very useful -- it's when you wrap your own logic around it that it becomes really powerful.

[plat_test]: https://github.com/wellcometrust/platform/blob/b34d5fc1635d0471fed2244015ef0f3e4e3445ef/.travis.yml#L40
[plat_deploy]: https://github.com/wellcometrust/platform/blob/b34d5fc1635d0471fed2244015ef0f3e4e3445ef/.travis.yml#L48
[hyp]: https://github.com/HypothesisWorks/hypothesis-python/blob/b697947e5df52d75f78f9dc93d3f858c659b0555/scripts/check-release-file.py

<br/>

```console
$ git merge-base --is-ancestor master my-branch; echo $?
0

$ git merge-base --is-ancestor other-branch my-branch; echo $?
1
```

This final command can tell you if one commit is the ancestor (directly precedes) another commit.
It exits with code 0 for yes, code 1 for no.

The example is based on the following branch structure:

<figure style="max-width: 80%" >
  <img src="/images/2017/git-ancestry.png" alt="">
  <figcaption>
    There are three commits up to <em>master</em> (marked in blue).
    There are then additional two commits atop master to <em>my-branch</em> (red), and three commits in a different branch from master, named <em>other-branch</em> (green).
  </figcaption>
</figure>

Most of the time, I'm comparing against master -- more specifically, the shared master that's been pushed to GitHub.
Checking that shared master is an ancestor of my current branch is a good way to ensure I don't inadvertently blat changes in master.

Let's look at an example.

<figure style="max-width: 80%">
  <img src="/images/2017/git-ancestry-bad.png" alt="">
  <figcaption>
    Now <em>master</em> has advanced another two commits (blue), while <em>other-branch</em> (green) hasn't moved.
  </figcaption>
</figure>

Consider the two commits in <em>master</em> but not in <em>other-branch</em>.
Suppose they contain important changes, and we've deployed them to a staging server.
If we do a deployment from <em>other-branch</em>, we'll deploy our changes and revert the already-deployed changes from <em>master</em>.
This opens the door for mistakes and confusion -- so we can use `--is-ancestor` to check we're only building on top of current master, not some earlier version of it.

In this case, a deployment from <em>other-branch</em> would be rejected until we'd rebased against master.

<br/>

I use all of these commands on a regular basis, but I bet there are others I'm missing.
What Git commands do you find indispensable?
What do you wish more people knew about?
I'd love to know what you find useful -- write your own blog post, or <a href="https://twitter.com/{{ site.social.twitter }}/">tell me on Twitter</a>.
